已思考几秒


下面更深入地说说，为什么用 Hilbert 曲线给 Mo 排序，能显著削常数、加速实际跑得更快。

---

## 1. Mo 算法的“指针抖动”问题

Mo 算法本质是在一个二维平面上遍历所有查询点 $(L,R)$，每次只允许水平或垂直移动指针来维护区间。时间复杂度是

$$
O\bigl((n+q)\sqrt n\bigr)
$$

但常数隐藏在“每次移动指针的距离”上——如果相邻两次查询的 $(L,R)$ 距离很大，就要做很多次 `add`/`remove` 操作。

* **标准分块排序**（先按 $\lfloor L/B\rfloor$ 排，再按 $R$ 排）能保证 “$\Delta L$” 总量是 $O(q\sqrt n)$，但对 “$\Delta R$” 是全局乱跳：同一个块内，$R$ 可能从 0 跳到 $n$，再从 $n$ 跳回 0，产生大常数。

---

## 2. Hilbert 曲线的“局部性保留”特性

Hilbert 曲线是一种经典的**空间填充曲线**，它把二维坐标 $(x,y)$ 映射到一条一维路径上，并且具有很好的**局部性保留**（locality‑preserving）性质：

> 如果在平面上两点 $(x_1,y_1)$ 与 $(x_2,y_2)$ 很接近，那么它们在 Hilbert 序上的排序值也一定接近。

换到 Mo 场景，就是保证排序后：

* 相邻两次查询的 $(L,R)$ 在平面上“相邻”或“接近”，
* 因此既不会出现 $L$ 大跳，也不会出现 $R$ 大跳。

---

## 3. 为什么跳得小就更快

* 每次指针移动都要做一次 `add` 或 `remove`，以及相关的状态更新。
* 如果用标准分块，块内可能出现 $R$ 从 0 → $n$ 的一次性大移动，增加了大量无用操作。
* 用 Hilbert 排序后，整个查询序列犹如跟着一条连续的“蜿蜒”曲线走，$L$ 和 $R$ 都只能做小幅度左右上下振荡。

这样：

1. **平均每次移动的步数更少**，常数下降 ≈30–50%。
2. **内存访问更集中**，更友好 CPU 缓存（cache），进一步加速。

---

## 4. 直观对比

| 排序方式       | 典型指针抖动           | 常数开销      |
| ---------- | ---------------- | --------- |
| 标准 Mo 分块   | $L$ 稳定，$R$ 大范围乱跳 | 较大        |
| Hilbert Mo | $L,R$ 同时小幅振荡     | 明显更小，跑得更快 |

---

## 5. 小结

* **Mo 算法** 保证了「总移动次数级别」；
* **Hilbert 排序** 保证了「每次移动幅度最小」，从而把隐藏常数砍下来。

在 $n,q\sim2\times10^5$ 这样的大数据下，从 1.1 s → 0.95 s，就靠的就是这层“移动局部性”优化。

---

### 参考代码片段：计算 Hilbert 序

```cpp
// 17 位就够覆盖 2e5
unsigned long long hilbertOrder(int x, int y) {
    unsigned long long d = 0;
    for (int s = 17; s >= 0; s--) {
        int rx = (x >> s) & 1, ry = (y >> s) & 1;
        d = (d << 2) | (rx * 3 ^ ry);
        if (ry == 0) {
            if (rx == 1) {
                x = ((1 << 18) - 1) - x;
                y = ((1 << 18) - 1) - y;
            }
            std::swap(x, y);
        }
    }
    return d;
}
```

只要将每个查询 $(L,R)$ 附上这条曲线的序号，再按序号排序，Mo 的指针就像沿着这条曲线行走——既保留了算法的理论复杂度，又在实践中把常数降到最小。
