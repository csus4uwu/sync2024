[toc]

每个月会选出个人最喜欢的题目——猪蹄奖。

> 4 月猪蹄奖：[cf 1804g](https://codeforces.com/contest/1804/problem/G)
>
> 很适合引入“势能”概念的题。一层层分析、优化复杂度很爽。

> 5 月猪蹄奖：[cf 2104g](https://codeforces.com/contest/2104/problem/G)
> 
> 非常综合的题目，可撤销并查集 + 线段树分治只是一个维护的途径，核心是欧拉定理的运用，朴素又巧妙。笔者因为这道题去学习了线段树分治。

> 6 月猪蹄奖：[cf 845g](https://codeforces.com/contest/845/problem/G)
> 
> 非常经典的老题。

---

# April

## [abc 399f](https://atcoder.jp/contests/abc399/tasks/abc399_f)
给定长为 $n$ 的序列 $a$ 和 $k$，求

$$
\sum_{1\leq l\leq r\leq n}\left(\sum_{l\leq i\leq r} a_i\right)^k 
$$

- $1 \leq n\leq 2\times 10^5$
- $1 \leq k \leq 10$

思路：$k$ 很小，考虑二项式展开。

我们先将里面的求和转化为前缀和相减的形式 $s_r - s_{l-1}$。然后固定右端点，二项式展开。观察 $l-1$ 从 $0$ 到 $r-1$，这部分不用一个一个加，可以再对 $s$ 作前缀和，从而预处理出来。因此复杂度减少一个 $n$。总复杂度 $O(nk)$。

## [cf 1988e *](https://codeforces.com/contest/1988/problem/E)

给定长为 $n$ 的排列 $a$，设 $f(a)$ 表示

$$
\sum_{1\leq l\leq r\leq n} \min_{l\leq i\leq r} a_i
$$

现在对每一个 $1\leq i \leq n$，依次求删去位置 $i$ 后 $f(a')$ 的值。

- $1\leq n\leq 5\times 10^5$

思路：

不删怎么做：非常经典，由于每个区间一定有一个最小值，我们反过来找每个值对应的，以它为最小值的所有区间，来统计贡献即可。怎么找呢？单调栈求它左右两边第一个大于它的数即可。或者线段树二分，或者二分 + rmq，方法很多。

回到原题，先想想看删掉 $i$，对 $j$ 产生的贡献有什么影响？分类讨论一下，以左边为例，设以 $a_x$ 为最小值的极大区间为 $(l_x, r_x)$：

- $i<l_j$：没有影响；
- $i=l_j$：相当于 $j$ 左边的屏障被删掉了，那就再往左边找屏障；
- $l_j<i<j$：屏障还在，但是里面的元素被删了一个；
- $j=i$：$i$ 被删，那么它产生的所有贡献都没了。

在右边也是一样的，不赘述了。

同样地，反过来想，对于 $j$，删掉哪些东西能影响它造成的贡献呢？影响多少？也就是说 $j$ 对 $f(i)$ 的影响。可以发现这是区间加的形式，那么用树状数组或者差分维护就行了。

这种“反过来”的思维还是很常见的，一些东西直接统计是 $O(n^2)$，反过来就能优化成 $O(n\log n)$ 或者线性。

具体实现详见 [代码](https://codeforces.com/contest/1988/submission/313612307)，这题质量很高。

## [cf 1804g **](https://codeforces.com/contest/1804/problem/G)

$n$ 个用户要传输数据，每个用户使用时间从 $s_i$ 到 $f_i$，初始传输速度为 $d_i$。网络的带宽为 $b$。

同一时刻，设每个参与传输的用户传输速度为 $t_i$。若 $\sum t_i \leq b$，则每个 $t_i\leftarrow t_i+1$；否则每个 $t_i\leftarrow \lfloor \frac {t_i}2\rfloor$。求直到最后一个用户停止传输，所有用户的传输量之和。

- $1\leq n\leq 2\times 10^5$
- $1\leq b, s_i, f_i, d_i\leq 10^9$

非常好的势能分析题，写了比较详细的[题解](https://www.luogu.com.cn/article/q4d30z9d)。

## [cf 2086d](https://codeforces.com/contest/2086/problem/D)

给定每个小写字母的出现次数 $c_i$，要构造一个字符串，使 $\forall (i, j), s_i=s_j$ 有 $|i-j|\equiv0\mod2$。

赛时没做出来，掉大分了。一直在想怎么搜索剪枝，其实要用背包求和为 $\frac n2$ 的方案数，然后套个组合数即可——奇偶位置各自是可以乱排，但是每种字母出现顺序不影响，那么就是将上述方案数乘上 $\dfrac{\lfloor\frac n2\rfloor!\lfloor\frac {n+1}2\rfloor!}{\prod c_i!}, c_i \neq 0$。

## [cf 1902d](https://codeforces.com/contest/1902/problem/D)

机器人初始在 $(0, 0)$，根据给定的操作序列上下左右移动。现在给 $q$ 个独立询问，每个询问中，问机器人能不能在翻转 $(l, r)$ 的情况下经过 $(x, y)$。

- $n, q \leq 2\times 10^5$

思路：

首先有一个重要的性质——翻转区间的前面和后面是不变的。因为翻转不会改变各操作的次数。那么再考虑翻转区间中的点有什么变化。

一个在 $(a_1, b_1)$ 和 $(a_2, b_2)$ 区间中的点 $(x, y)$，意味着操作向量 $\vec o =(x-a_1, y-b_1)$，翻过去就是 $(a_2-x+a_1, b_2-y+b_1)$。即起点和终点作和，减去 $(x, y)$。

因此记录从点到操作次序的映射。通过二分，来找上述的三个区间中有没有合法的操作能实现。

## [cf 1841d](https://codeforces.com/contest/1841/problem/D)

$n$ 个线段，删去一些线段。两两配对，每一对的两个线段相交；任意两对之间都不相交。求删去线段的最小数量。

- $n \leq 2000$

思路：

先预处理出所有能相交的线段，他们的并集。放到另一个新的数组中。然后就是经典的最大不相交线段数量问题——对右端点排序之后贪心扫过去即可。

## [cf 2103d](https://codeforces.com/contest/2103/problem/D)

一个排列 $p$，依次循环进行以下操作直到只剩一个元素：

- 删去非局部最小的位置；
- 删去非局部最大的位置。

现在告诉你每个位置被删去的轮次（若是最后留存即为 $-1$），构造出一个符合的排列。

- $n \leq 2\times 10^5$

思路：

模拟。遍历轮次，维护还存留的数。每一轮中，先找**第一个**在这一轮不会被删的位置，以这个位置为基准。接下来看这一轮要删的所有数该怎么构造.

先讨论奇数轮的情况，要保证所有删去的位置不是局部最小。我们按照从左边到基准，从右边到基准的顺序，依次填最大值。

```text
7 6 x ... 3 ... 4 5
```

想象一个形式如上的情形（$x$ 为基准），可以发现这些位置一定满足非局部最小，无论它的两边是谁。

偶数轮同理，我们按照相同的顺序，依次填最小值。

该方法的正确性证明较繁琐，这里不赘述了。


## [cf 2104e](https://codeforces.com/contest/2104/problem/E)

对于只包含前 $k$ 个小写字母的字符集，给出一个字符串 $s$，$q$ 个询问，每个询问给出一个字符串 $t_i$，求最少在 $t_i$ 末尾添加几个字符，能让 $t_i$ 不是 $s$ 的子序列。

- $|s| \leq 10^6,\ q\leq 2\times 10^5$

思路：

非常经典的子序列自动机。先处理对于每个位置右边，每种字符第一次出现的位置 $f_{i, c}$，由这个再处理到每个位置再加多少字符能跳出去 $dp_i$。

对于给出的 $t$，先用 $f$ 来快速定位作为子序列的 $t$，末尾在 $s$ 的位置 $p$，答案就是 $dp_p$。复杂度 $O(nk)$，[代码](https://codeforces.com/contest/2104/submission/317659700)。

## [cf 2106g1 *](https://codeforces.com/contest/2106/problem/G1)

交互题。

$n$ 个节点的树，所有点权要么是 $1$ 要么是 $-1$，你可以问 $n+200$ 个问题，两种类型：

- 给出 $k$ 个点的集合 $a$，回答 $\sum f(a_i)$，其中 $f(a_i)$ 表示从根走到 $a_i$ 的路径上所有点权之和。

- 翻转某一个点的权值，$1\rightarrow -1$ 或 $-1\rightarrow 1$

最终需要输出每个点的点权。

- $n\leq 10^3$
- 该树为菊花图。所有点都连接到 $1$（不代表 $1$ 为根）。

思路：

由于把树形限制成以 $1$ 为心的菊花图，这题好做很多。分为 $1$ 是否为根两种情况。

对于 $1$ 是根的情况，有 $f(1)=w_1$，那就很好做了，其他所有点都有 $w_i=f(i)-f(1)$。

不是根的情况，首先需要找到哪个是根才能像第一种情况这么处理。这里我们选择翻转 $1$ 的权值，如果一个点 $i$ 不是根，在翻转 $1$ 之后，有 $f(i) \leftarrow f(i) \pm 2$，而如果它是根，则 $f(i)$ 保持不变。只有一个点是根，那么就可以二分找出第一个不变的点了。

具体而言，在翻转前先求出所有 $f(i)$ 并作前缀和。翻转后，在 $[2, n]$ 中二分，询问 $\sum_{i=2}^{x} f(i)$，并与原来的区间和作差判断。

问的问题个数近似 $(n+\log n)$，可以通过，[代码](https://codeforces.com/contest/2106/submission/317079684)。

## [P5522 棠梨煎雪](https://www.luogu.com.cn/problem/P5522)

$m$ 个长度 $n$ 的二进制字符串，字符串中有的位置不确定，记为 `?`。两个字符串匹配，仅当相同位置不同时出现 `0` 和 `1`。

$q$ 个询问，类型如下：

- 把指定位置的字符串更换为给出的新字符串；
- 匹配从 $l$ 到 $r$ 的所有字符串的方案数。

- $n\leq 30,\  m\leq 10^5,\  q\leq 10^6$

思路：

看到 $n$ 不超过 $30$，可以采用状态压缩的方式来表示一个字符串。一种比较好写的方法是：用 $60$ 位的 $\texttt{std::bitset}$，两位表示一个字符：

- `00`：这个位置冲突了
- `01`：这个位置是 `0`
- `10`：这个位置是 `1`
- `11`：这个位置是 `?`

这样两个字符串信息合并的方式可以采用与运算。对于询问方案数，统计从 $l$ 到 $r$ 全都与起来的结果中，是否有冲突，以及 `?` 的数量 $s$。如果没有冲突，答案为 $2^{s}$，否则就是 $0$。

用线段树维护即可，复杂度 $O(\dfrac{qn\log m}{w})$。

## [P1525 关押罪犯 *](https://www.luogu.com.cn/problem/P1525)

$n$ 个罪犯，$m$ 条边，每条边表示两个罪犯发生冲突的影响力。要把这些罪犯分到两个监狱里，仅当两个囚犯关在一个监狱，才会发生冲突。求冲突的最大影响力的最小值。

- $n\leq 2\times 10^4,\ m\leq 10^5$

思路：

拓展域并查集。以边权从大到小排序后遍历，不断将端点 $x$ 和 $\bar y$、以及 $y$ 和 $\bar x$ 合并，直到某条边的 $x$ 和 $y$ 已经联通，那就没救了，答案就是这条边的权值。

## [CF gym 102307d *](https://codeforces.com/gym/102307/problem/D)

一个字符串 $s$，$q$ 个询问。每个询问给出 $i, a, k, c$，要求把 $s_i, s_{i+a}, s_{i+2a},...,s_{i+ka}$ 的位置替换为 $c$。输出最终的字符串。

- $|s|\leq 10^5,\ q\leq 10^5$

思路：

根号分治。公差 $a$ 不小于 $\sqrt n$ 的，我们直接暴力遍历，来看 $a<\sqrt n$ 的情况。

首先，要优化更新的次数，可以把询问倒过来处理，再维护每个位置是否被修改过。这样每个位置至多被更新一次。

现在我们希望前面的操作能留下一些信息，来表示这块区间已经跑过了。对小于 $\sqrt n$ 的每个公差，用 $f_{a, i}$ 表示 $i$ 右边第一个没被遍历到的点，初始肯定是 $i+a$，操作时一边跳一边转移前面的。

但是这么做的效率仍然是不可接受的，我们可以用并查集优化，每次操作都以右端点为根合并即可。总复杂度 $O(q\sqrt n)$。[代码](https://codeforces.com/gym/102307/submission/317768548)

## [P1196 银河英雄传说 *](https://www.luogu.com.cn/problem/P1196)

$n$ 艘船，初始时每条船单独占一列。$T$ 个询问，两种类型：

- 把 $x$ 所在的列，挪到 $y$ 所在的列的末尾，两列内部顺序不变
- 询问 $x$ 和 $y$ 是否在同一列，如果在，输出它们之间隔了多少船。

思路：

维护一个 $\text{dis}_i$ 来表示每艘船到它所在列的首艘船的距离，询问距离很好做。但在把一列挪到另一列的时候，如果一条一条船更新，效率无法接受。

用带权并查集来优化。一般的并查集在实现 `find()` 查找根的功能时，会用循环。这里要用一个递归的方式，具体地：先一路找到根，在回溯的时候进行距离的更新，把 x 节点父亲的距离加到它本身上，最后再将父节点设置为根。也就是说，这里的 `find()` 其实承担了更新节点信息的功能，而我们的懒标记放在队头就行了。

举个例子来模拟一下，由

```
1 2
3 4 5
```

变为


```
3 4 5 1 2
```

合并操作**只**更新了原第一行的队头 $\text{dis}_1\leftarrow 0+3$，而 $\text{dis}_2 = 1$ 还没更新，在询问到点 $2$ 时，$2$ 先链接到 $1$，再链接到现在的队头 $3$，再回去，$2$ 就吃了 $1$ 的信息，$\text{dis}_2 \leftarrow 1+3 =4$。

## [P1197 星球大战](https://www.luogu.com.cn/problem/P1197)

$n$ 个点 $m$ 条边，$k$ 个询问，每个询问永久删去一个点和与它相连的边，求每次询问之后图中的连通块个数。

思路：

把询问倒过来，那就变成了不断加点，这就非常好做了，用并查集维护即可。我的做法是，每次加点加边过程中，用 $\texttt{std::set}$ 记录新点连接到的连通块的根的个数 $cnt$。此次加点就会减少 $cnt-1$ 个连通块。

## [P10389 成绩统计 (lqb)](https://www.luogu.com.cn/problem/P10389)

$n$ 个人，每个人的成绩为 $a_i$。从前往后统计，问至少到第几个人，能选出 $k$ 个连续的人，他们的方差小于 $T$。

- $n, k \leq 10^5$

思路：

首先，如果到 $x$ 个人能选出来，那对任意 $y\ge x$ 也能选出来，答案有单调性，考虑二分。

先给方差一个定性的性质：方差是表示样本离散程度的，如果要方差小，那样本要尽可能靠得近。因此我们将 $x$ 个人排序，然后用单调队列跑过去，维护最小的方差即可。

# May

- 【专题】线段树分治：以时间作定义域，开一颗线段树。把信息存到对应时间区间的节点里。然后再以递归遍历整棵树的形式，来求得所有时间的答案。

先给出加边的流程形式，线段树每个节点管辖范围 $[l, r)$ 实质上是管辖了 $[l, r)$ 时间中的所有边。
```cpp
vector<vector<array<int, 2>>> info(4 * k);

auto addEdge = [&](auto &&self, int p, int l, int r, int x, int y, int u, int v) -> void {
    if (l >= y or r <= x) {
        return;
    }
    if (l >= x and r <= y) {
        info[p].push_back({u, v});
        return;
    }
    int m = (l + r) / 2;
    self(self, 2 * p, l, m, x, y, u, v);
    self(self, 2 * p + 1, m, r, x, y, u, v);
};
```

然后是求解的流程形式——对整棵树进行 dfs，每一个叶子节点，即管辖范围 $r-l=1$ 的区间，都是一个时刻 $t=l$ 的答案。

```cpp
auto work = [&](auto &&self, int p, int l, int r, bool ok) -> void {
    // 记录现场
    ...

    for (auto [u, v] : info[p]) {
        // 对这个时间区间的边进行处理
    }
    if (r - l == 1) {
        // 此时到叶子节点，就是 time = l 的答案
    } else {
        // 继续递归
        int m = (l + r) / 2;
        self(self, 2 * p, l, m, ok);
        self(self, 2 * p + 1, m, r, ok);
    }

    // 还原现场
    ...
};
```

为什么它能优于暴力呢？简单来说，一条出现在任意时间段的边，都能通过线段树分治，储存在至多 $2\log t$ 个节点中，由此将 $t$ 优化为 $\log t$ 级别。

## [P5787 二分图](https://www.luogu.com.cn/problem/solution/P5787)

思路：

首先先想，如何判断一个图是不是二分图。由于二分图中一条边的两个端点一定不在相同集合中。采用拓展域并查集，将每个点 $x$ 分成两个点，$x_s$ 和 $x_t$。每条边等价于将 $u_s$ 与 $v_t$，$v_s$ 与 $u_t$ 合并。如果最后存在 $x_s$ 和 $x_t$ 在一个集合中，则这个图不是二分图。

再套用线段树分治和可撤销并查集，就做出来了。更新时，每加一条边 $(u, v)$，就判断一次 $u$ 和 $v$ 的合法性，维护这个节点是否为二分图，并随递归传递下去，一个小剪枝是：如果知道不合法，就不用再更新（也可以不加）。

复杂度 $O(k\log n\log k)$。

## [cf 2069f](https://codeforces.com/contest/2069/problem/F)

同样地，我们首先来想，对于一个静态图 $A$ 和 $B$，要使 $A$ 包含 $B$，最少要加多少边呢？

设 $C = A\cup B$，答案就是 $A$ 与 $C$ 的连通块个数的差。

套用线段树分治，分别维护两个并查集 $A$ 和 $C$，以及它们的连通块个数即可。详见[代码](https://codeforces.com/contest/2069/submission/318018084)，打了注释，比较好读。

## [cf 2104g *](https://codeforces.com/contest/2104/problem/G)

先考虑一个静态的图。

缩点之后形成有向无环图，以拓扑序进行染色，那么每个强连通分量，可以想染成什么就染成什么，则答案为 $k^c$，$c$ 为强连通分量的数量。

对 $3$ 取模很有意思，由欧拉定理有 $a^2\equiv 1\bmod 3$，则答案与 $k^{c\bmod 2}$ 同余。

现在每个询问都会修改边，那么问题在于怎么动态地求强连通分量的数量——当然不能每个询问都跑一遍 tarjan。注意到这个图有一个特性：每个点仅有一条出边，这就意味着一个强连通分量一定是一个环。

答案和 $c$ 的奇偶性有关。我们可以想象，只有一个环，它有 $u$ 个顶点，则 $c=n-u+1$，当且仅当 $u$ 是偶数，那么 $c$ 会改变其奇偶性。推广到一般的情况，这个结论也成立。

那么我们只需要统计偶环的个数即可，偶环的个数是连通块个数减去奇环个数，奇环的个数等价于不是二分图的连通块的个数，用上面模板题的方法维护就行了。

详见[代码](https://codeforces.com/contest/2104/submission/318373703)。

问题：推广到任意模数怎么做？

---

## [cf 1970e3 *](https://codeforces.com/contest/1970/problem/E3)

先看 $m\leq 10^2$ 的 e2，做一个 $m\times m$ 的矩阵 $M$，$M_{i, j}$ 表示从 $i$ 走到 $j$ 的方案数。设向量 $\bold v_x$ 表示走了 $x$ 天后到达各点的方案数。

最开始在点 $1$，则 $\bold v_0=(1,0,0, \dots, 0)$。

转移也很简单，对于一个点，到达它的方案数，是前一天所有点到达这个点，的方案之和。即有 $\bold v_{x+1}=M\bold v_{x}$。

则 $\bold v_{n}=M^n\bold v_{0}$，用矩阵快速幂可得，复杂度 $O(m^3\log n)$。答案为 $\bold v_{n}$ 中所有元素之和。

再看 $m\leq 10^5$，$M$ 太大了，考虑优化。

我们知道 $M_{i, j}=(s_i+l_i)(s_j+l_j)-l_il_j$，是两个数相减（相加）的形式，则我们可以把 $M$ 写成两个矩阵相乘，构造

$$
f=\left(
\begin{matrix}
s_1+l_1 & l_1\\ 
s_2+l_2 & l_2\\
\vdots & \vdots\\
s_n+l_n & l_n
\end{matrix}
\right)
$$

$$
g=\left(
\begin{matrix}
s_1+l_1 & s_2+l_2 & \cdots & s_n+l_n\\
-l_1 & -l_2 & \cdots & -l_n
\end{matrix}
\right)
$$

则 $M=fg$，$M^n=f(gf)^{n-1}g$，现在再算就行了。复杂度 $O(m+\log n)$。


## [cf 38e](https://codeforces.com/contest/38/problem/E)

默认弹珠已按 $x$ 坐标排序。

我们从最右边的弹珠开始往左推。想想最左边新加入一颗弹珠时，会怎么样。

首先，这颗新加入的弹珠一定要定死，不然罚款无限大。假如设 $f_i$ 为考虑弹珠 $i, i + 1, \dots, n$ 的最优答案，由于“最左边一定先定死”的特性，可以进行如下转移：

$$
f_i = \min_{i+1 \leq j \leq n} \left(c_i+\sum_{k=i}^{j-1}\text{dis}_{i, k} + f_j\right)
$$

简单来说，在 $i$ 到 $n$ 中，选一个点 $j$ 定死，这个点左边的弹珠让它自由滚到 $i$，右边就是 $f_j$。

复杂度 $O(n^2)$。

# June

## [cf 232b *](https://codeforces.com/contest/232/problem/B)

> 这里的列编号用 $\text{0-base}$。

每个 $n\times n$ 的区域里，恰好要放 $k$ 个。也就是在告诉我们，每一列 $\text{col}_i$ 放的棋子数量，和所有 $\text{col}_j \equiv \text{col}_i \bmod n$ 一样。

列数 $m$ 非常大，但由于我们有数量的限制，所以如果知道第 $i$ 列放 $x$ 个，则有 $\lceil \dfrac{m - i}{n}\rceil$ 个列都只能放 $x$ 个，所以我们只要讨论前 $n$ 列就足够了，不妨设第 $i$ 组列表示所有与 $i$ 同余 $n$ 的列，$\text{cnt}_i = \lceil \dfrac{m - i}{n}\rceil$。

到这里，转移就比较好想了。设 $f_{i,x}$ 表示前 $i$ 组列，每个 $n\times n$ 的区域放 $x$ 个的方案数，$f_{0,0}=1$。

对于第 $i$ 组列，假如这组中每一列要放 $j$ 个棋子（$0\leq j\leq n$），有

$$
\begin{align*}
g_{i, j} &:= \binom{n}{j} ^ {\text{cnt}_i}\\
f_{i, s+j} &\leftarrow f_{i, s+j} + f_{i-1, s}\times g_{i, j}, \ s \leq k-j

\end{align*}
$$

意思就是枚举 $j$ 和 $s$，原来每个区域放 $s$ 个的方案数，乘上这列放 $j$ 个的方案数，贡献到放 $s+j$ 个的方案数中。最终 $f_{n, k}$ 就是答案。

复杂度 $O(n^2k)$。

详见[代码](https://codeforces.com/contest/232/submission/320399268)。

## [cf1915g](https://codeforces.com/contest/1915/problem/G)

_不要吝啬状态的设置。_

多一个维度的单源最短路。设 $f_{u, b}$ 表示从城市 $1$ 开始到城市 $u$，且**目前选择**了自行车 $b$ 时的最短时间。

松弛的过程和经典 dijkstra 差不多。对于边 $u\rightarrow v$，先用目前的自行车骑过去，然后看看要不要换车。如果 $v$ 的自行车比目前的快，那就换。

## [cf 2113c](https://codeforces.com/contest/2113/problem/C)

需要注意到，第一个炸弹炸出的一片空地，都可以放第二个炸弹。那么我们可以一点一点将这个空地推出去。又因为“获得”的范围是边界上，则第一个炸弹爆炸后，剩余的金子我们都能得到。

那么就是要在所有空地中，寻找爆炸范围中金矿最少的那一个。

爆炸范围是一个矩形，则我们可以用二维前缀和来维护，复杂度 $O(nm)$。由于数据范围不大，也可以用遍历 + 一维前缀和的方式来做，复杂度与 $O(n^3)$ 同阶。

## [P4344 脑洞治疗仪 *](https://www.luogu.com.cn/problem/P4344)

懒标记线段树好题。

怎么维护最长连续？效仿维护最大子段和的方式：前缀最优、后缀最优、全段最优。区间合并时，新的最优来自左边的最优、右边的最优，或者左后缀 + 右前缀。

来看更新操作，第一个就是挖一块，那太简单了，来一个覆盖的 tag 就行。

第二个是先挖一块，再填一块。优先填左边的空，如果多出来就扔掉。那我们首先需要知道挖出来了多少——节点再维护一个 $sum$。

接下来，该怎么填呢？我们让 tag 能表示什么都不敢、覆盖 $0$（挖）和覆盖 $1$（填）。效仿线段树二分的形式，维护剩余数量 $rest$ 往下，先左后右地递归。

感觉光说有点干燥，放一下这部分的代码。

```cpp
template <class Info, class Tag>
struct LazySegmentTree {

    /**
    ...
    */

    int fill(int p, int l, int r, int x, int y, int rest) {
        if (l >= y or r <= x) {
            return rest;
        }
        // 如果这个区间包含在 [x, y) 中，
        // 且 rest >= 缺失的，那就直接填上然后 return
        if (l >= x and r <= y and info[p].act - info[p].sum <= rest) {
            int ori = info[p].act - info[p].sum;
            apply(p, Tag{2});
            return rest - ori;
        }
        // 否则往下递归
        int m = (l + r) / 2;
        push(p);
        // 先递归左边
        rest = fill(2 * p, l, m, x, y, rest);
        // 如果 rest 还有剩余，就继续递归右子树
        if (rest) {
            rest = fill(2 * p + 1, m, r, x, y, rest);
        }
        pull(p);
        return rest;
    }
    int fill(int l, int r, int x) {
        return fill(1, 0, n, l, r, x);
    }
};
```

三个操作的复杂度均为 $O(\log n)$，总共复杂度为 $O(m\log n)$。

在挖一部分填一部分时，也有一个 $O(\log n \log n)$ 的办法——固定左端点，二分出第一个**满足缺失部分不少于挖下来的数量**的区间，然后直接 `rangeApply` 即可。

## [cf 2120d *](https://codeforces.com/contest/2120/problem/D)

很好玩的计数题。

由于要字典序最小，我们先考虑行，也就是一维的情况，那很简单了，当 $n=(a-1)k+1$，一定选不到 $a$ 个相同的数。

todo

# July

7 月猪蹄奖：待定。

## [cf 2123g](https://codeforces.com/contest/2123/problem/g)

需要一些数论的基础。

- 让 $a_i \leftarrow (a_i+k) \bmod m$，$a_i \bmod \gcd(m, k)$ 的值是不会改变的，即 $a_i$ 在 $\gcd(m, k)$ 的同余类中。

先给定一个 $k$，设 $d=\gcd(m, k)$。接下来我们来看看怎么操作序列 $a$。

既然能任意次操作，贪心地想，我们可以让每个 $a_i$ 尽可能小。由于 $a_i$ 一定在 $d$ 的同余类中，最小肯定就是 $a_i \bmod d$ 了。

但是 $a$ 得是非递减的，如果 $a_{i-1} > a_i\bmod d$，那么 $a_i$ 就得变成 $(a_i\bmod d) + d$ 了，可以理解为抬高一级，后面的位置也都要抬高。

现在就很明朗了，什么情况下可以操作成功呢？就是抬高的级数小于 $\dfrac md$，如果不小于，那么 $a_i$ 理应超过 $m$ 了，但 $a_i < m$，因此不可行。

$k$ 是它给我的，但是 $d$ 是确定的，我们先处理出 $m$ 的所有因子 $d$，这道题就做出来了。先预处理，碰到点修就再把那个位置的，所有因子的情况更新一下。复杂度 $O((n+q) \tau(m))$。[代码](https://codeforces.com/contest/2123/submission/327413244)。


## [cf 2121g *](https://codeforces.com/contest/2121/problem/g)

设 $g_i$ 表示在前 $i$ 个位置中，$1$ 于 $0$ 的个数差 $\#1-\#0$（并不一定是正数）。
$$
\begin{align*}
f(s_ls_{l+1}\dots s_r)&=\max (\#0, \#1)\\
&=\frac{\#1+\#0 + |\#1-\#0|}{2}\\
&=\frac{r-l+1+|g_r - g_{l-1}|}{2}
\end{align*}
$$

分为长度和 $g$ 的贡献两部分，则有

$$
\begin{align*}
2\sum_{1\leq l\leq r\leq n}f(s_ls_{l+1}\dots s_r)&=\sum_{1\leq l \leq r\leq n}(r-l+1)\\
&+ \sum_{1\leq l\leq r\leq n}|g_r - g_{l-1}|
\end{align*}
$$

第一项很好算，跳过了。来看第二项，这个绝对值有点不好搞，但由于 $l$ 和 $r$ 是无序的，将 $g$ 从小到大排序，能把上式中的绝对值去掉。

$$
\begin{align*}
Ans_2&=\sum_{1\leq l\leq r\leq n}\left(g_r - g_{l-1}\right)\\
&=\sum_{i=1}^{n-1} (g_{i+1}-g_i)\times i\times (n-i)
\end{align*}
$$

意思就是：相邻两个的差，左边选一个位置，右边选一个位置，那这个差就会对答案产生一次贡献。有多少种选法，就产生多少次贡献。显然有 $i\times (n-i)$ 种选法。

复杂度 $O(n\log n)$，[代码](https://codeforces.com/contest/2121/submission/325326336)。

还有一个较麻烦的方法：从前到后扫，对 $g_i$ 的值域开两个树状数组，分别维护**区间下标数量**，和**区间贡献**。对于 $i$，把它产生的贡献分为 $\#0$ 多和 $\#1$ 多，左右两部分进行计算。可参考[代码](https://codeforces.com/contest/2121/submission/325326112)。

## [P1868 饥饿的奶牛](https://www.luogu.com.cn/problem/P1868)

可以选任意多的线段，但不能重复，需要一个不能统计重复的遍历方法。

设 $f_x$ 为 $[0, x)$ 最多能选多少，对于它给的一条线段 $[l, r)$，我们在走到 $r$ 的时候再拿出来，让 $f_r \leftarrow \max(f_r, f_l+r-l)$，这样就不会统计到重复的了。其他时候 $f_r \leftarrow f_{r-1}$。

怎么走到 $r$ 再拿出来呢？将给出的线段变为终点到起点的映射即可。

## [P3558 BAJ-Bytecomputer](https://www.luogu.com.cn/problem/P3558)

首先需要发现，用最优策略，最终数组的每个数仍然只有 $-1,0,1$ 三种可能，否则一定是不优的。

设 $f_{i, x}$ 为前 $i$ 个位置，结尾为 $x$ 且**合法**时的最小操作次数。初始 $f_{1, x_1}=0$，其他全是 $\inf$。

以 $x_i$ 的值，做分类讨论即可。例如 $x_i=1$，如果：

- 它要变成 $-1$，就需要前一个数是 $-1$，然后操作两次，即 $f_{i, -1}\leftarrow f_{i-1, -1}+2$；

- 要变成 $0$，同样需要前一个数是 $-1$，然后操作一次，即 $f_{i, 0}\leftarrow f_{i-1, -1}+1$；

- 要变成 $1$，什么都不用做，前一个数任意，选次数最小的转移，即 $f_{i, 1}\leftarrow \min_{j=-1}^1\{f_{i-1, j}\}$。

$x_i$ 为其他值的时候也是这么分析，就不赘述了。

## [cf 2124f](https://codeforces.com/contest/2124/problem/F1)

这场 D 不会，一直在做 F1，思路搞错了，最后也没做出来。

先从一个错误的解法开始：

设 $f_i$ 表示前 $i$ 个位置的方案数。对于 $i$，枚举长度 $s$ 和起始数 $r$，然后看 $[i-s+1, i]$ 这么填是不是满足所有限制，如果满足，令 $f_i \leftarrow f_i+f_{i-s+1}$，$O(n^4)$，看上去很对，**但是错了**。

考虑一个情况，`1 2 1`，如果按上述方法，可以是 `1 2|1`，也可以是 `1|2 1`，就重复计算了。

因此还需要限制一点：如果一个块是 `1 2 3 ... x` 这么填的，那么这个块后面，不能以 `x + 1` 开始。

实现层面，需要多设置一个维度，设 $f_{i,j}$ 表示前 $i$ 个位置，且后面一个位置填 $j$ 的方案数。

对于以 $i$ 结尾，长度 $s$，起始为 $x$ 的一块合法方案，有 $f_{i, j}\leftarrow f_{i,j}+f_{i-s+1,x}, \ 1\leq j\leq n$，如果 $x=1$，那么 $f_{i, s+1}$ 不动即可。

复杂度仍然是 $O(n^4)$，[代码](https://codeforces.com/contest/2124/submission/327832696)是 0-base 左闭右开的，与上述细节上有一点不同。

f2 - todo

## [SHCPC-2025 E](https://qoj.ac/contest/2238/problem/12563)

势能线段树。

- 如果 $v$ 是一个区间的 $\text{lcm}$ 的因子，则直接返回。

- 如果一个区间都是同一个数，就覆盖。

否则继续往下递归。

复杂度 $O(n\log^3 n)$，分别为线段树、势能增长，和 $\gcd$ 与 $\text{lcm}$。不是很会严谨地证明，以后学会了再来补写证明部分。

实现上，需要注意的是，判断一个区间是否为同一个数，可以用区间长度整除区间和、且区间和 / 区间长度等于区间 $\text{lcm}$。**不要用 `tag` 是否存在作为判断依据**，会漏情况，然后 T。

[代码](https://qoj.ac/submission/1144249) | [哥哥的代码](https://qoj.ac/submission/1142980)。